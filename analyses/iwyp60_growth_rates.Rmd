---
title: "Exploring growth rates IWYP"
author: "A Bowerman, D Ganguly"
date: "21/05/2019"
output: html_document
---

## Aim 
Calculate growth rates from NDVI data.

## Method
Utilise measures of Normalized Vegetation Index (NDVI, Greenseeker) to estimate growth rates using a nonlinear modelling approach [Paine et al 2012](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/j.2041-210X.2011.00155.x).

Also see [Fitting von Bertalanffy Growth Function](http://rpubs.com/lacs/1123) and [fishR](http://derekogle.com/fishR/examples/oldFishRVignettes/VonBertalanffy.pdf).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, warning = FALSE, message = FALSE)

library(tidyverse)
library(DBI) ## functions to interface with databases
library(RMySQL) ## database implementation
library(rstudioapi)

## connect to germinat3 db with read-only account
con <- dbConnect(MySQL(),
          dbname="iwyp60_germinate_dev",
          user = "iwyp60ro",
          host = 'wheatyield.anu.edu.au')

## read tables required to pull database info
table_names <- dbListTables(con)
rq_tables <- c("phenotypedata", "phenotypes", "grouptypes", "datasets", "experiments", "germinatebase", 'groups', 'groupmembers')
tables <- lapply(FUN=dbReadTable, X=rq_tables, conn=con)
names(tables) <- rq_tables

## pull data needed
dat_init <- select(tables$phenotypedata, phenotype_id, germinatebase_id, dataset_id, phenotype_value) %>%
  full_join(., tables$phenotypes, by=c("phenotype_id"="id")) %>%
  full_join(., tables$germinatebase, by=c("germinatebase_id"="id")) %>%
  full_join(., tables$datasets, by=c("dataset_id"="id")) %>%
  select(-breeders_code, -breeders_name, -subtaxa_id, -puid, -colldate, -collcode, -collname, -collmissid, -othernumb, -duplsite, -duplinstname)

## disconnect from database
dbDisconnect(con)

## get accession groups and members together
accs <- filter(tables$groups, grouptype_id == 3) %>%
  left_join(tables$groupmembers, by=c("id"="group_id")) %>%
  mutate(general_id = tables$germinatebase$general_identifier[match(foreign_id, tables$germinatebase$id)])

## Extract NDVI values
dat <- filter(dat_init, sapply(strsplit(short_name,";"), function(l) l[1]) == "NDVI") %>%
  select(source_file, general_identifier, phenotype_id, germinatebase_id, experiment_id, dataset_id, short_name, phenotype_value) %>%
  mutate(trait = sapply(strsplit(short_name, ";"), function(l) l[1])) %>%
  mutate(date = sapply(strsplit(short_name, ";"), function(l) l[2])) %>%
  mutate(date = paste0(date,sapply(strsplit(source_file,"_"), function(l) l[1]))) %>%
  mutate(date = as.Date(date, tryFormats = c("%d%b%Y"))) %>%
  rename(value = phenotype_value) %>%
  mutate(value = as.numeric(paste(value))) %>%
  mutate(dataset = tables$datasets$description[match(dataset_id, tables$datasets$id)])

## clean up workspace
rm(list = c('dat_init','con','tables','table_names','rq_tables'))

```

## Results
As an initial exploratory exercise, we can produce a heatmap to look at individual growth behaviours.

```{r}
library(pheatmap)

## make numeric matrix and heatmap
my_mat <- select(dat, germinatebase_id, date, value) %>%
  group_by(germinatebase_id, date) %>%
  summarise(avg = mean(value)) %>%
  spread(date, avg)

my_mat <- as.data.frame(my_mat)
rownames(my_mat) <- my_mat$germinatebase_id
my_mat <- as.matrix(my_mat[2:ncol(my_mat)])

# define accession annotations
my_grps <- select(accs, foreign_id, name)
my_grps <- subset(my_grps, foreign_id %in% rownames(my_mat))
rownames(my_grps) <- my_grps$foreign_id
my_grps$foreign_id <- NULL

pheatmap(mat = my_mat,
         show_rownames = F,
         main = "NDVI measures",
         annotation_row = my_grps,
         cutree_rows = 4,
         cluster_cols = FALSE,
         angle_col = 45
        )

```

We can arbitrarily group the data into 4 temporal patterns (cutree algorithm). Interestingly, the data doesn't completely separate by panel.

We can also plot raw NDVI values with a generic loess polynomial fit. 

```{r}
library(ggplot2)
library(patchwork)

### plot jitter
ggplot(dat, aes(x=date, y=value)) + 
  geom_jitter() + 
  facet_wrap(~dataset) + 
  geom_smooth(method='loess') +
  scale_y_continuous(name = "NDVI") +
  scale_x_date(name = "Measuring date") +
  ggtitle("NDVI data") +
  theme(legend.position = "none")
```

Polynomial models are clearly *not* appropriate for plant growth modelling and are thus discouraged (Paine et al 2012). Instead, we will attempt to fit asymptotic non-linear models:

1. *3P logistic*
2. *4P logistic*

*N.B. Gompertz would not converge*

Which fitting routine to use [nls, _gnls_, or nlme]? If there are no treatment effects (ie y ~ x) use gnls. It can do everything that nls can do, but additionally allows variance modelling to deal with heteroscedasticity. Also, gnls allows you to choose which parameters should vary among treatment groups, and which should be global (Pinheiro & Bates, pg 401). However, occasionally gnls will fail to converge. In those cases, nls can still be useful. nlme can do all of the above, as well as allowing for fixed and (nested) random effects. However, it requires a somewhat different syntax for specifying the model (Pinheiro, J.C., and Bates, D.M. 2000).

```{r setup mdl data, include=FALSE}
library(nlme)

df <- dat %>%
  rename(X=date, Y=value, group=general_identifier) %>% 
  mutate(X_num = as.numeric(X)) %>%
  mutate(dataset = sapply(strsplit(dataset, " "), function(l) l[1])) %>%
  filter(X != "2018-11-16") %>%
  select(Y,X,X_num,group,dataset) %>% 
  mutate(logY = log10(Y))
  
df_exk <- subset(df, dataset == "GES18_ExKsub")
df_ext <- subset(df, dataset == "GES18_Extras")

n.preds=100
r <- range(df$X_num)
xNew <- seq(r[1],r[2],length.out = n.preds)
```

### Exploratory modelling with the 3-parameter logistic

```{r}
#fit
fit.logis.exk  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = df_exk)
yfitted.exk <- predict(fit.logis.exk, list(X_num = xNew))

fit.logis.ext  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = df_ext)
yfitted.ext <- predict(fit.logis.ext, list(X_num = xNew))

par(mfrow = c(1,2))

#plot
plot(Y ~ X, df_exk, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted.exk, col = 'red')
mtext("GES18 ExK", font=3, padj = -1)

plot(Y ~ X, df_ext, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted.ext, col = 'red')
mtext("GES18 Extras", font=3, padj = -1)

```

Visualize scaled residuals and model fits for each model.

```{r, echo=FALSE}
p3 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.exk), y=residuals(fit.logis.exk)/sd(residuals(fit.logis.exk)))) +
  ggtitle("3P Logistic GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p4 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.ext), y=residuals(fit.logis.ext)/sd(residuals(fit.logis.ext)))) +
  ggtitle("3P Logistic GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p3 + p4

out <- rbind(c("Logistic exk", round(fit.logis.exk$logLik)),
             c("Logistic ext", round(fit.logis.ext$logLik))
)

colnames(out) <- c("Model", "logLik")
out
```

As a trial, the 3P logistic model is fitted to each dataset. It is the more commonly used form as it has a point of inflexion and is a relatively flexible and parsimonious model. We can continue modelling using the 3P logistic model with *SSlogis* to improve the model fit. We can include a dummy time-point at T=0 and see if the model converged on log10 transformed data. A 4-P logistic model gives greater flexibility and can help explain greater variance. It did not converge previously, however, the inclusion of T=0 may facilitate parsimony.

```{r, include=FALSE}
dummy <- NULL
for(i in unique(interaction(df$group, df$dataset))){
  a <- tibble(Y = 0, X=as.Date("2018-07-08"), 
              logY=log10(0.01),
              group=sapply(strsplit(i, "\\."), function(l) l[1]),
              X_num = as.numeric(X),
              dataset= sapply(strsplit(i, "\\."), function(l) l[2]))
  dummy <- rbind(dummy, a)
}

## convert date to days for meaningful rates
new_df <- rbind(dummy, df) %>%
  mutate(days = lubridate::interval(min(X),X)) %>%
  mutate(days = lubridate::as.duration(days)) %>%
  mutate(days = as.numeric(days)/60/60/24) %>%
  mutate(X=days) %>%
  select(-X_num, -days)

df_exk <- subset(new_df, dataset == "GES18_ExKsub")
df_ext <- subset(new_df, dataset == "GES18_Extras")

n.preds=100
r <- range(new_df$X)
xNew <- seq(r[1],r[2],length.out = n.preds)
```

```{r}
#fit
fit.logis.exk  <- gnls( Y ~ SSlogis(X, Asym, xmid, scal), data = df_exk)
yfitted.exk <- predict(fit.logis.exk, list(X = xNew))

fit.logis.ext  <- gnls( Y ~ SSlogis(X, Asym, xmid, scal), data = df_ext)
yfitted.ext <- predict(fit.logis.ext, list(X = xNew))

fit.fpl.exk <- gnls( Y ~ SSfpl(X, A, B, xmid, scal), data = df_exk)
yfitted2.exk <- predict(fit.fpl.exk, list(X = xNew))

fit.fpl.ext <- gnls( Y ~ SSfpl(X, A, B, xmid, scal), data = df_ext)
yfitted2.ext <- predict(fit.fpl.ext, list(X = xNew))

par(mfrow = c(2,2))

#plot
plot(Y ~ X, df_exk, ylab = "NDVI", xlab = "Days")
lines(xNew, yfitted.exk, col = 'red')
mtext("3P GES18 ExK", font=3, padj = -1)

plot(Y ~ X, df_ext, ylab = "NDVI", xlab = "Days")
lines(xNew, yfitted.ext, col = 'red')
mtext("3P GES18 Extras", font=3, padj = -1)

plot(Y ~ X, df_exk, ylab = "NDVI", xlab = "Days")
lines(xNew, yfitted2.exk, col = 'red')
mtext("4P GES18 ExK", font=3, padj = -1)

plot(Y ~ X, df_ext, ylab = "NDVI", xlab = "Days")
lines(xNew, yfitted2.ext, col = 'red')
mtext("4P GES18 Extras", font=3, padj = -1)

```

```{r, echo=FALSE}
p1 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.exk), y=residuals(fit.logis.exk)/sd(residuals(fit.logis.exk)))) +
  ggtitle("3P GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p2 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.ext), y=residuals(fit.logis.ext)/sd(residuals(fit.logis.ext)))) +
  ggtitle("3P GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p3 <- ggplot() + 
  geom_point(aes(x=fitted(fit.fpl.exk), y=residuals(fit.fpl.exk)/sd(residuals(fit.fpl.exk)))) +
  ggtitle("4P GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p4 <- ggplot() + 
  geom_point(aes(x=fitted(fit.fpl.ext), y=residuals(fit.fpl.ext)/sd(residuals(fit.fpl.ext)))) +
  ggtitle("4P GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p1 + p2 + p3 + p4

out <- rbind(c("3P ExK", round(fit.logis.exk$logLik)),
             c("3P Extras", round(fit.logis.ext$logLik)),
             c("4P ExK", round(fit.fpl.exk$logLik)),
             c("4P Extras", round(fit.fpl.ext$logLik))
)

colnames(out) <- c("Model", "logLik")
out
```

### Growth rates from 3P logistic regression
Determine AGR, RGRm, and RGRt *per plot* (ie. using plot IDs = "_IW_P_XYZv") using 3P logistic fit.

```{r}
par(mfrow = c(3,3))

# plot and fit to 9 random accessions
for(i in sample(1:length(unique(new_df$group)), size = 9, replace = FALSE)){
  tryCatch({
      id <- unique(new_df$group)[i]
      a <- subset(new_df, group == id)
      tmp <- getInitial(Y ~ SSlogis(X, Asym, xmid, scal), data = a)
      fit  <- gnls( Y ~ SSlogis(X, Asym, xmid, scal), data = a, start=tmp)
      yfitted <- predict(fit, list(X = xNew))
      
      plot(Y ~ X, a, ylab = "NDVI", xlab = "Days", ylim = c(0,.8))
      lines(xNew, yfitted, col = 'red')
      mtext(paste(id), font=3, padj = -1)
      
  }, 
  error = function(e){cat("ERROR @ #", i, ":", conditionMessage(e), "\n")})
  
}

# logLik on last plot
logLik(fit)

```

> 3P logistic seems parsimonious with these datasets. Can use it to assemble coefficients for all plant plot/accessions ideas for the entire GES18 campaign. Any IDs for which the model does not converge are ignored and dropped.

```{r}
# transform paramters of 3P logistic model
transform_param.logis <- function(coef){
	K = coef[1]
	r = 1/(coef[3])
	M0 =  K/(1 + exp(coef[2]/coef[3])) #untransform best-fit parameters to K, r and M0
	if(is.data.frame(K)){
		out <- cbind(K, r, M0)
		} else {
		out <- c(K, r, M0)
		}
	names(out) <- c("K", "r", "M0")
	return(out)
}

cfs_logis <- NULL

for(i in 1:length(unique(new_df$group))){
  tryCatch({
      id <- unique(new_df$group)[i]
      a <- subset(new_df, group == id)
      tmp <- getInitial(Y ~ SSlogis(X, Asym, xmid, scal), data = a)
      fit  <- gnls( Y ~ SSlogis(X, Asym, xmid, scal), data = a, start=tmp)
      x <- transform_param.logis(coef(fit))
      tmp2 <- tibble(id = id, K=x[1], r=x[2], M0 = x[3])
      cfs_logis <- rbind(cfs_logis, tmp2)
  }, error = function(e) {})
}

p1 <- ggplot(data = cfs_logis) + geom_histogram(aes(x=K), fill = "salmon", colour='black')
p2 <- ggplot(data = cfs_logis) + geom_histogram(aes(x=r), fill = "dodgerblue", colour='black') 
p3 <- ggplot(data = cfs_logis) + geom_histogram(aes(x=M0), fill = "goldenrod", colour='black') 

p1 + p2 + p3

```

Check that the parameter profiles are approximately V-shaped (and that the sampling intervals of the parameters are therefore approximately multivariate normal) before proceeding.

```{r}
tmp <- getInitial( Y ~ SSlogis(X, Asym, xmid, scal), data = df_ext)
fit  <- nls( Y ~ SSlogis(X, Asym, xmid, scal), data = df_ext, start=tmp)

par(mfrow=c(2,2))

plot(profile(fit))
```

> Profiles are V-shaped

```{r}
rates <- NULL
cfs <- cfs_logis # use 3p logistic results

for(i in cfs$id){
  tmp_rates <- tibble(
    id = i,
    K = cfs$K[cfs$id == i],
    M0 = cfs$M0[cfs$id == i],
    r = cfs$r[cfs$id == i],
    times = xNew,
    M  = (M0*K)/(M0+(K-M0)*exp(-r*times)),           
    AGR  = (r*M0*K*(K-M0)*exp(-r*times))/(M0+(K-M0)*exp(-r*times))^2,
    RGRt = AGR/M,
    RGRm = r*(1 - M/K)
  )

  rates <- rbind(rates, tmp_rates)
}

head(rates)

par(mfrow=c(2,2))

for(i in sample(1:length(unique(rates$id)), size = 2, replace = FALSE)){
  tryCatch({
      Id <- unique(new_df$group)[i]
      a <- subset(new_df, group == Id)
      
      tmp <- getInitial( Y ~ SSlogis(X, Asym, xmid, scal), data = a) 
      fit  <- gnls( Y ~ SSlogis(X, Asym, xmid, scal), data = a, start = tmp)
      yfitted <- predict(fit, list(X = xNew))
      
      # "biomass"
      plot(Y ~ X, data = a, ylab = "NDVI", xlab = "Days", ylim = c(0,.8))
      lines(xNew, yfitted, col = 'red')
      mtext(paste(Id), font=3, padj = -1)
      
      b <- subset(rates, id == Id)
      
      # AGR
      plot(AGR ~ times, data=b, type = "n", xlab='Days', ylab = expression(paste("AGR ", (unit^-1%.%day^-1))))
      lines(AGR ~ times, data = b)
      
      # RGRt
      plot(RGRt ~ times, data=b, type = "n", xlab='Days', ylab = expression(paste("RGR ", (unit%.%unit^-1%.%day^-1))))
      lines(RGRt ~ times, data = b)
      
      # RGRm
      plot(RGRm ~ M, data=b, type = "n", xlab='NDVI', ylab = expression(paste("RGR ", (unit%.%unit^-1%.%day^-1))))
      lines(RGRm ~ M, data = b)
  }, 
  error = function(e){cat("ERROR @ #", i, ":", conditionMessage(e), "\n")})
  
}

```

### Growth rates from 4P logistic regression

Determine AGR, RGRm, and RGRt *per plot* (ie. using plot IDs = "_IW_P_XYZv") using 4P logistic fit.

```{r}
par(mfrow = c(3,3))

# plot and fit to 9 random accessions
for(i in sample(1:length(unique(df_ext$group)), size = 9, replace = FALSE)){
  tryCatch({
      id <- unique(df_ext$group)[i]
      a <- subset(df_ext, group == id)
      tmp <- getInitial(Y ~ SSfpl(X, A, B, xmid, scal), data = a) #4p logistic
      fit  <- gnls( Y ~ SSfpl(X, A, B, xmid, scal), data = a, start = tmp) #4p logistic
      yfitted <- predict(fit, list(X = xNew))
      
      plot(Y ~ X, a, ylab = "NDVI", xlab = "Days", ylim = c(0,.8))
      lines(xNew, yfitted, col = 'red')
      mtext(paste(id), font=3, padj = -1)
      
  }, 
  error = function(e){cat("ERROR @ #", i, ":", conditionMessage(e), "\n")})
  
}

# logLik on last plot
logLik(fit)
```

```{r}
## fit fpl on all accessions and extract coefficients based on Paine et al 2012.
cfs_fpl <- NULL

for(i in 1:length(unique(new_df$group))){
  tryCatch({
      id <- unique(new_df$group)[i]
      a <- subset(new_df, group == id)
      tmp <- getInitial(Y ~ SSfpl(X, A, B, xmid, scal), data = a) #4p logistic
      fit  <- gnls( Y ~ SSfpl(X, A, B, xmid, scal), data = a, start = tmp) #4p logistic
      x <- coef(fit)
      tmp2 <- tibble(id = id, M0=x[1], K=x[2], xmid=x[3], r = x[4])
      cfs_fpl <- rbind(cfs_fpl, tmp2)
  }, error = function(e) {})
}

p1 <- ggplot(data = cfs_fpl) + geom_histogram(aes(x=K), fill = "salmon", colour='black')
p2 <- ggplot(data = cfs_fpl) + geom_histogram(aes(x=r), fill = "dodgerblue", colour='black')
p4 <- ggplot(data = cfs_fpl) + geom_histogram(aes(x=xmid), fill = "forestgreen", colour='black')
p3 <- ggplot(data = cfs_fpl) + geom_histogram(aes(x=M0), fill = "goldenrod", colour='black')

p1 + p2 + p4 + p3
```

Before trying to make predictions, we also want to make sure we can propagate error in parameter estimates into growth rate estimates. Before propagating error, we need to check that the parameter profiles are approximately V-shaped (and that the sampling intervals of the parameters are therefore approximately multivariate normal) before proceeding.

```{r}
tmp <- getInitial(Y ~ SSfpl(X, A, B, xmid, scal), data = df_ext)
fit  <- nls( Y ~ SSfpl(X, A, B, xmid, scal), data = df_ext, start=tmp)

par(mfrow=c(2,2))

plot(profile(fit))
```

> Profiles are v-shaped

```{r}
rates <- NULL
cfs <- cfs_fpl # use 4p logistic results

for(i in cfs$id){
  tmp_rates <- tibble(
    id = i,
    K = cfs$K[cfs$id == i],
    M0 = cfs$M0[cfs$id == i],
    xmid = cfs$xmid[cfs$id == i],
    r = cfs$r[cfs$id == i],
    times = xNew,
    ex = exp((xmid-times)/r),
    M  = M0+(K-M0)/(1+ex),           
    AGR  = ((K-M0)*ex)/(r*(1+ex)^2),
    RGRt = AGR/M,
    RGRm = ((M0-M)*(K-M))/(r*M*(M0-K))
  )

  rates <- rbind(rates, tmp_rates)
}

head(rates, n=3)

par(mfrow=c(2,2))

# plot and fit to 9 random accessions
for(i in sample(1:length(unique(rates$id)), size = 2, replace = FALSE)){
  tryCatch({
      Id <- unique(new_df$group)[i]
      a <- subset(new_df, group == Id)
      
      tmp <- getInitial(Y ~ SSfpl(X, A, B, xmid, scal), data = a) #4p logistic
      fit  <- gnls( Y ~ SSfpl(X, A, B, xmid, scal), data = a, start = tmp) #4p logistic
      yfitted <- predict(fit, list(X = xNew))
      
      # "biomass"
      plot(Y ~ X, data = a, ylab = "NDVI", xlab = "Days", ylim = c(0,.8))
      lines(xNew, yfitted, col = 'red')
      mtext(paste(Id), font=3, padj = -1)
      
      b <- subset(rates, id == Id)
      
      # AGR
      plot(AGR ~ times, data=b, type = "n", xlab='Days', ylab = expression(paste("AGR ", (unit^-1%.%day^-1))))
      lines(AGR ~ times, data = b)
      
      # RGRt
      plot(RGRt ~ times, data=b, type = "n", xlab='Days', ylab = expression(paste("RGR ", (unit%.%unit^-1%.%day^-1))))
      lines(RGRt ~ times, data = b)
      
      # RGRm
      plot(RGRm ~ M, data=b, type = "n", xlab='NDVI', ylab = expression(paste("RGR ", (unit%.%unit^-1%.%day^-1))))
      lines(RGRm ~ M, data = b)
  }, 
  error = function(e){cat("ERROR @ #", i, ":", conditionMessage(e), "\n")})
  
}

```



