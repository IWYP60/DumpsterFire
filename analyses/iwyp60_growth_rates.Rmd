---
title: "Exploring growth rates IWYP"
author: "A Bowerman, D Ganguly"
date: "21/05/2019"
output: html_document
---

### Aim 
Explore growth rates across IWYP field trial data.

### Method

Utilise measures of Normalized Vegetation Index (NDVI, Greenseeker) to estimate growth rates using a nonlinear modelling approach [Paine et al 2012](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/j.2041-210X.2011.00155.x).


Also see [Fitting von Bertalanffy Growth Function](http://rpubs.com/lacs/1123) and [fishR](http://derekogle.com/fishR/examples/oldFishRVignettes/VonBertalanffy.pdf).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, warning = FALSE, message = FALSE, results = 'asis')

library(tidyverse)
library(DBI) ## functions to interface with databases
library(RMySQL) ## database implementation
library(rstudioapi)

## connect to germinat3 db with read-only account
con <- dbConnect(MySQL(),
          dbname="iwyp60_germinate_dev",
          user = "iwyp60ro",
          host = 'wheatyield.anu.edu.au')

## read tables required to pull database info
table_names <- dbListTables(con)
rq_tables <- c("phenotypedata", "phenotypes", "grouptypes", "datasets", "experiments", "germinatebase", 'groups', 'groupmembers')
tables <- lapply(FUN=dbReadTable, X=rq_tables, conn=con)
names(tables) <- rq_tables

## pull data needed
dat_init <- select(tables$phenotypedata, phenotype_id, germinatebase_id, dataset_id, phenotype_value) %>%
  full_join(., tables$phenotypes, by=c("phenotype_id"="id")) %>%
  full_join(., tables$germinatebase, by=c("germinatebase_id"="id")) %>%
  full_join(., tables$datasets, by=c("dataset_id"="id")) %>%
  select(-breeders_code, -breeders_name, -subtaxa_id, -puid, -colldate, -collcode, -collname, -collmissid, -othernumb, -duplsite, -duplinstname)

## disconnect from database
dbDisconnect(con)

## get accession groups and members together
accs <- filter(tables$groups, grouptype_id == 3) %>%
  left_join(tables$groupmembers, by=c("id"="group_id")) %>%
  mutate(general_id = tables$germinatebase$general_identifier[match(foreign_id, tables$germinatebase$id)])

## Extract NDVI values
dat <- filter(dat_init, sapply(strsplit(short_name,";"), function(l) l[1]) == "NDVI") %>%
  select(source_file, general_identifier, phenotype_id, germinatebase_id, experiment_id, dataset_id, short_name, phenotype_value) %>%
  mutate(trait = sapply(strsplit(short_name, ";"), function(l) l[1])) %>%
  mutate(date = sapply(strsplit(short_name, ";"), function(l) l[2])) %>%
  mutate(date = paste0(date,sapply(strsplit(source_file,"_"), function(l) l[1]))) %>%
  mutate(date = as.Date(date, tryFormats = c("%d%b%Y"))) %>%
  rename(value = phenotype_value) %>%
  mutate(value = as.numeric(paste(value))) %>%
  mutate(dataset = tables$datasets$description[match(dataset_id, tables$datasets$id)])

## clean up workspace
rm(list = c('dat_init','con','tables','table_names','rq_tables'))

```

### Results

As an initial exploratory exercise, we can produce a heatmap to look at individual growth behaviours.

```{r}
library(pheatmap)

## make numeric matrix and heatmap
my_mat <- select(dat, germinatebase_id, date, value) %>%
  group_by(germinatebase_id, date) %>%
  summarise(avg = mean(value)) %>%
  spread(date, avg)

my_mat <- as.data.frame(my_mat)
rownames(my_mat) <- my_mat$germinatebase_id
my_mat <- as.matrix(my_mat[2:ncol(my_mat)])

# define accession annotations
my_grps <- select(accs, foreign_id, name)
my_grps <- subset(my_grps, foreign_id %in% rownames(my_mat))
rownames(my_grps) <- my_grps$foreign_id
my_grps$foreign_id <- NULL

pheatmap(mat = my_mat,
         show_rownames = F,
         main = "NDVI measures",
         annotation_row = my_grps,
         cutree_rows = 4,
         cluster_cols = FALSE,
         angle_col = 45
        )

```

The data appear to group into 4 temporal behaviours.

We can also plot raw NDVI values with a generic loess polynomial fit. 

```{r}
library(ggplot2)
library(patchwork)

### plot jitter
ggplot(dat, aes(x=date, y=value)) + 
  geom_jitter() + 
  facet_wrap(~dataset) + 
  geom_smooth(method='loess') +
  scale_y_continuous(name = "NDVI") +
  scale_x_date(name = "Measuring date") +
  ggtitle("NDVI data") +
  theme(legend.position = "none")
```

## Plant growth modelling

Polynomial models are clearly *not* appropriate for plant growth modelling and are thus discouraged (Paine et al 2012). Instead, we will attempt to fit various asymptotic non-linear models:

1. *Monomolecular*
2. *3-P Logistic*

*N.B. 4-P logistic and Gompertz models would not converge.*

Which fitting routine to use [nls, _gnls_, or nlme]? If there are no treatment effects (ie y ~ x) use gnls. It can do everything that nls can do, but additionally allows variance modelling to deal with heteroscedasticity. Also, gnls allows you to choose which parameters should vary among treatment groups, and which should be global (Pinhero & Bates, pg 401). However, occasionally gnls will fail to converge. In those cases, nls can still be useful. Use nlsList to fit a series of nls models (this is rarely useful in practice. Rather, you probably want to use nlme) nlme can do all of the above, as well as allowing for fixed and (nested) random effects. However, it requires a somewhat different syntax for specifying the model (Pinheiro, J.C., and Bates, D.M. 2000).

```{r setup mdl data, include=FALSE}
library(nlme)

df <- dat %>%
  rename(X=date, Y=value, group=general_identifier) %>% 
  mutate(X_num = as.numeric(X)) %>%
  mutate(dataset = sapply(strsplit(dataset, " "), function(l) l[1])) %>%
  select(Y,X,group,X_num, dataset) %>% 
  mutate(logY = log10(Y)) %>%
  filter(X != "2018-11-16") # remove last data point

df_exk <- subset(df, dataset == "GES18_ExKsub")
df_ext <- subset(df, dataset == "GES18_Extras")

n.preds=100
r <- range(df$X_num)
xNew <- seq(r[1],r[2],length.out = n.preds)
```

Starting dataframes for regression

```{r, results='markup'}
head(df_exk, n =4)
head(df_ext, n =4)
```

### Monomolecular

```{r, results='markup'}
#fit
fit.mono.exk <- gnls(logY ~ SSasymp(X_num, Asym, R0, lrc), data = df_exk)
yfitted.exk <- predict(fit.mono.exk, list(X_num = xNew))

fit.mono.ext <- gnls(logY ~ SSasymp(X_num, Asym, R0, lrc), data = df_ext)
yfitted.ext <- predict(fit.mono.ext, list(X_num = xNew))

par(mfrow = c(1, 2))

#plot
plot(logY ~ X, df_exk, ylab = "log10 NDVI", xlab = "Date")
lines(xNew, yfitted.exk, col = 'red')
mtext("GES18 ExK", font=3, padj = -1)

plot(logY ~ X, df_ext, ylab = "log10 NDVI", xlab = "Date")
lines(xNew, yfitted.ext, col = 'red')
mtext("GES18 Extras", font=3, padj = -1)
```

### 3-parameter Logistic

```{r, results='markup'}
#fit
fit.logis.exk  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = df_exk)
yfitted.exk <- predict(fit.logis.exk, list(X_num = xNew))

fit.logis.ext  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = df_ext)
yfitted.ext <- predict(fit.logis.ext, list(X_num = xNew))

par(mfrow = c(1,2))

#plot
plot(Y ~ X, df_exk, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted.exk, col = 'red')
mtext("GES18 ExK", font=3, padj = -1)

plot(Y ~ X, df_ext, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted.ext, col = 'red')
mtext("GES18 Extras", font=3, padj = -1)

```

### Compare models

Visualize scaled residuals and model fits for each model.

```{r, echo=FALSE, results='markup'}
p1 <- ggplot() + 
  geom_point(aes(x=fitted(fit.mono.exk), y=residuals(fit.mono.exk)/sd(residuals(fit.mono.exk)))) +
  ggtitle("Monomolecular GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p2 <- ggplot() + 
  geom_point(aes(x=fitted(fit.mono.ext), y=residuals(fit.mono.ext)/sd(residuals(fit.mono.ext)))) +
  ggtitle("Monomolecular GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p3 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.exk), y=residuals(fit.logis.exk)/sd(residuals(fit.logis.exk)))) +
  ggtitle("3P Logistic GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p4 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.ext), y=residuals(fit.logis.ext)/sd(residuals(fit.logis.ext)))) +
  ggtitle("3P Logistic GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p1 + p2 + p3 + p4

out <- rbind(c("Monomolecular exk", round(fit.mono.exk$logLik)),
             c("Logistic exk", round(fit.logis.exk$logLik)),
             c("Monomolecular ext", round(fit.mono.ext$logLik)),
             c("Logistic ext", round(fit.logis.ext$logLik))
)

colnames(out) <- c("Model", "logLik")
out
```

Interestingly, the monomolecular fit appears to fit best, however, the model form is not ideal for modelling plant growth (e.g. no point of inflexion, can predict negative biomass). The 3P logistic fit is more commonly used form as it has a point of inflexion and is a relatively flexible and parsimonious model. We can continue modelling using the 3P logistic model with *SSlogis* to improve the model fit. We can include a dummy time-point at T=0 and see if the model converged on log10 transformed data. A 4-P logistic model gives greater flexibility and can help explain greater variance. It did not converge previously, however, the inclusion of T=0 may facilitate parsimony.

```{r, include=FALSE}
dummy <- NULL
for(i in unique(interaction(df$group, df$dataset))){
  a <- tibble(Y = 0, X=as.Date("2018-07-08"), 
              logY=log10(0.01),
              group=sapply(strsplit(i, "\\."), function(l) l[1]),
              X_num = as.numeric(X),
              dataset= sapply(strsplit(i, "\\."), function(l) l[2]))
  dummy <- rbind(dummy, a)
}

new_df <- rbind(df, dummy)

df_exk <- subset(new_df, dataset == "GES18_ExKsub")
df_ext <- subset(new_df, dataset == "GES18_Extras")

n.preds=100
r <- range(new_df$X_num)
xNew <- seq(r[1],r[2],length.out = n.preds)
```

```{r, results='markup'}
#fit
fit.logis.exk  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = df_exk)
yfitted.exk <- predict(fit.logis.exk, list(X_num = xNew))

fit.logis.ext  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = df_ext)
yfitted.ext <- predict(fit.logis.ext, list(X_num = xNew))

fit.fpl.exk <- gnls( Y ~ SSfpl(X_num, A, B, xmid, scal), data = df_exk)
yfitted2.exk <- predict(fit.fpl.exk, list(X_num = xNew))

fit.fpl.ext <- gnls( Y ~ SSfpl(X_num, A, B, xmid, scal), data = df_ext)
yfitted2.ext <- predict(fit.fpl.ext, list(X_num = xNew))

par(mfrow = c(2,2))

#plot
plot(Y ~ X, df_exk, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted.exk, col = 'red')
mtext("3P GES18 ExK", font=3, padj = -1)

plot(Y ~ X, df_ext, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted.ext, col = 'red')
mtext("3P GES18 Extras", font=3, padj = -1)

plot(Y ~ X, df_exk, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted2.exk, col = 'red')
mtext("4P GES18 ExK", font=3, padj = -1)

plot(Y ~ X, df_ext, ylab = "NDVI", xlab = "Date")
lines(xNew, yfitted2.ext, col = 'red')
mtext("4P GES18 Extras", font=3, padj = -1)

```

```{r, echo=FALSE, results='markup'}
p1 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.exk), y=residuals(fit.logis.exk)/sd(residuals(fit.logis.exk)))) +
  ggtitle("3P GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p2 <- ggplot() + 
  geom_point(aes(x=fitted(fit.logis.ext), y=residuals(fit.logis.ext)/sd(residuals(fit.logis.ext)))) +
  ggtitle("3P GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p3 <- ggplot() + 
  geom_point(aes(x=fitted(fit.fpl.exk), y=residuals(fit.fpl.exk)/sd(residuals(fit.fpl.exk)))) +
  ggtitle("4P GES18 ExK") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p4 <- ggplot() + 
  geom_point(aes(x=fitted(fit.fpl.ext), y=residuals(fit.fpl.ext)/sd(residuals(fit.fpl.ext)))) +
  ggtitle("4P GES18 Extras") +
  scale_y_continuous("Scaled residuals") + scale_x_continuous("Fitted values")

p1 + p2 + p3 + p4

out <- rbind(c("3P ExK", round(fit.logis.exk$logLik)),
             c("3P Extras", round(fit.logis.ext$logLik)),
             c("4P ExK", round(fit.fpl.exk$logLik)),
             c("4P Extras", round(fit.fpl.ext$logLik))
)

colnames(out) <- c("Model", "logLik")
out
```

#### NLS Regression per plant plot ID

Continue with the 3P logistic model. Use this to determine AGR, RGRm, and RGRt *per plot* (ie. using plot IDs = "_IW_P_XYZv"). For this, we will need *nlme* to converge so we can assign plot ID as a fixed effect and also include spatial info as random (TBD). 

```{r, results='markup'}
## model IDs in GES18 ExK
## need to use getInitial to get initial estimates which allows model to converge
## use tryCatch() to deal with non-convergence

par(mfrow = c(3,3))

# plot and fit to 9 random accessions
for(i in sample(1:length(unique(df_exk$group)), size = 9, replace = FALSE)){
  tryCatch({
      id <- unique(df_exk$group)[i]
      a <- subset(df_exk, group == id)
      tmp <- getInitial(Y ~ SSlogis(X_num, Asym, xmid, scal), data = a)
      fit  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = a, start=tmp)
      # tmp <- getInitial(Y ~ SSfpl(X_num, A, B, xmid, scal), data = a) #4p logistic
      # fit  <- gnls( Y ~ SSfpl(X_num, A, B, xmid, scal), data = a, start = tmp) #4p logistic
      yfitted <- predict(fit, list(X_num = xNew))
      
      plot(Y ~ X, a, ylab = "NDVI", xlab = "Date", ylim = c(0,.8))
      lines(xNew, yfitted, col = 'red')
      mtext(paste(id), font=3, padj = -1)
      
  }, 
  error = function(e){cat("ERROR @ #", i, ":", conditionMessage(e), "\n")})
  
}

# logLik on last plot
logLik(fit)

```

```{r, results='markup'}
## model IDs in GES18 Extras

par(mfrow = c(3,3))

# plot and fit to 9 random accessions
for(i in sample(1:length(unique(df_ext$group)), size = 9, replace = FALSE)){
  tryCatch({
      id <- unique(df_ext$group)[i]
      a <- subset(df_ext, group == id)
      tmp <- getInitial(Y ~ SSlogis(X_num, Asym, xmid, scal), data = a)
      fit  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = a, start=tmp)
      # tmp <- getInitial(Y ~ SSfpl(X_num, A, B, xmid, scal), data = a) #4p logistic
      # fit  <- gnls( Y ~ SSfpl(X_num, A, B, xmid, scal), data = a, start = tmp) #4p logistic
      yfitted <- predict(fit, list(X_num = xNew))
      
      plot(Y ~ X, a, ylab = "NDVI", xlab = "Date", ylim = c(0,.8))
      lines(xNew, yfitted, col = 'red')
      mtext(paste(id), font=3, padj = -1)
      
  }, 
  error = function(e){cat("ERROR @ #", i, ":", conditionMessage(e), "\n")})
  
}

# logLik on last plot
logLik(fit)
```

Both 3P and 4P models converge for individual plant plot IDs (or Accession IDs) and having similar log likelihood values (goodness of fit). Therefore, we can continue with either to produce coefficients on a plant plot basis to use to estimate RGR and AGR. For simplicity, the above code and the following analysis using the 3P logistic model. 

#### Collate coefficients for models per plant plot ID 

Assemble coefficients for all plant plot/accessions ideas for the entire GES18 campaign. Any IDs for which the model does not converge are ignored and dropped.

```{r, results='markup'}
# transform paramters of logistic model
transform_param.logis <- function(coef){
	K = coef[1]
	r = 1/(coef[3])
	M0 =  K/(1 + exp(coef[2]/coef[3])) #untransform best-fit parameters to K, r and M0
	if(is.data.frame(K)){
		out <- cbind(K, r, M0)
		} else {
		out <- c(K, r, M0)
		}
	names(out) <- c("K", "r", "M0")
	return(out)
}

cfs <- NULL

for(i in 1:length(unique(new_df$group))){
  tryCatch({
      id <- unique(new_df$group)[i]
      a <- subset(new_df, group == id)
      tmp <- getInitial(Y ~ SSlogis(X_num, Asym, xmid, scal), data = a)
      fit  <- gnls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = a, start=tmp)
      # tmp <- getInitial(Y ~ SSfpl(X_num, A, B, xmid, scal), data = a) #4p logistic
      # fit  <- gnls( Y ~ SSfpl(X_num, A, B, xmid, scal), data = a, start = tmp) #4p logistic
      x <- transform_param.logis(coef(fit))
      tmp2 <- tibble(id = id, K=x[1], r=x[2], M0 = x[3])
      cfs <- rbind(cfs, tmp2)
  }, error = function(e) {})
}

head(cfs)

p1 <- ggplot(data = cfs) + geom_histogram(aes(x=K), fill = "salmon", colour='black')
p2 <- ggplot(data = cfs) + geom_histogram(aes(x=r), fill = "dodgerblue", colour='black') 

p1 + p2

```

#### Predictions on RGRm and AGR

Before trying to make predictions, we also want to make sure we can propagate error in parameter estimates into growth rate estimates. Before propagating error, we need to check that the parameter profiles are approximately V-shaped (and that the sampling intervals of the parameters are therefore approximately multivariate normal) before proceeding.

```{r}
tmp <- getInitial(Y ~ SSlogis(X_num, Asym, xmid, scal), data = new_df)
fit  <- nls( Y ~ SSlogis(X_num, Asym, xmid, scal), data = new_df, start=tmp)

par(mfrow=c(2,2))

plot(profile(fit))
```

Profiles are v-shaped.

```{r, eval=FALSE}
times = unique(new_df$X_num)
newTime = abs(min(times) - times)

rates <- NULL

# for(i in cfs$id){

i = "IW_P04899"
  K <- cfs$K[cfs$id == i]
  M0 = 0.01 ## hacky hack M0 = 0 is a problem .... double check right eqn
  r <- cfs$r[cfs$id == i]
  tmp <- tibble(
    time = newTime,
    M = (M0*K)/(M0+(K-M0)*exp(-r*times)),
    AGR = (r*M0*K*(K-M0)*exp(-r*times))/(M0+(K-M0)*exp(-r*times))^2)
	tmp$RGRt <- rates$AGR/rates$M
	tmp$RGRm <- r*(1 - rates$M/K)
  
# }

tmp
	
```




